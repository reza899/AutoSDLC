/**
 * BAML Client Wrapper for AutoSDLC Agents
 * 
 * Provides type-safe integration with BAML framework for all agent LLM interactions.
 * This wrapper handles schema validation, multi-model fallbacks, and error recovery.
 */

import { BamlClient, BamlRuntime, FunctionResult, FunctionResultStream } from '@boundaryml/baml';
import { AgentType, AgentStatus } from '../types/agent-types';
import * as path from 'path';
import * as fs from 'fs';

// Import generated BAML types (these will be generated by baml-cli)
// import * as BamlTypes from '../generated/baml';

export interface BamlConfig {
  projectRoot: string;
  defaultModel: string;
  fallbackModels?: string[];
  temperature?: number;
  maxTokens?: number;
  timeout?: number;
  retryPolicy?: RetryPolicy;
}

export interface RetryPolicy {
  maxRetries: number;
  backoffMultiplier: number;
  initialDelayMs: number;
}

export interface BamlFunctionCall<T> {
  functionName: string;
  input: any;
  expectedOutput: new () => T;
  model?: string;
  temperature?: number;
}

export class BamlClientWrapper {
  private client: BamlClient;
  private runtime: BamlRuntime;
  private config: BamlConfig;
  private initialized: boolean = false;

  constructor(config: BamlConfig) {
    this.config = config;
    this.client = {} as BamlClient; // Will be initialized in init()
    this.runtime = {} as BamlRuntime; // Will be initialized in init()
  }

  /**
   * Initialize BAML client and runtime
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Load BAML project configuration
      const projectPath = path.join(this.config.projectRoot, 'baml_project.yaml');
      if (!fs.existsSync(projectPath)) {
        throw new Error(`BAML project file not found at ${projectPath}`);
      }

      // Initialize BAML runtime with configuration
      this.runtime = new BamlRuntime({
        projectPath: this.config.projectRoot,
        defaultClient: this.config.defaultModel,
        clientConfig: {
          temperature: this.config.temperature ?? 0.7,
          maxTokens: this.config.maxTokens ?? 4096,
          timeout: this.config.timeout ?? 30000,
        }
      });

      // Create BAML client
      this.client = new BamlClient(this.runtime);
      
      this.initialized = true;
      console.log('BAML client initialized successfully');
    } catch (error) {
      console.error('Failed to initialize BAML client:', error);
      throw error;
    }
  }

  /**
   * Execute a BAML function with type safety and error handling
   */
  async executeFunction<T>(call: BamlFunctionCall<T>): Promise<T> {
    if (!this.initialized) {
      await this.initialize();
    }

    const models = [call.model || this.config.defaultModel, ...(this.config.fallbackModels || [])];
    let lastError: Error | null = null;

    // Try each model in sequence
    for (const model of models) {
      try {
        console.log(`Executing BAML function ${call.functionName} with model ${model}`);
        
        // Execute the function through BAML
        const result = await this.executeFunctionWithModel<T>(
          call.functionName,
          call.input,
          model,
          call.temperature
        );

        // Validate the result matches expected schema
        if (this.validateResult(result, call.expectedOutput)) {
          return result;
        } else {
          throw new Error('Result validation failed');
        }
      } catch (error) {
        console.error(`Failed with model ${model}:`, error);
        lastError = error as Error;
        
        // If not the last model, continue to fallback
        if (model !== models[models.length - 1]) {
          console.log(`Falling back to next model...`);
          continue;
        }
      }
    }

    // All models failed
    throw new Error(`All models failed for ${call.functionName}: ${lastError?.message}`);
  }

  /**
   * Execute a streaming BAML function
   */
  async *executeFunctionStream<T>(call: BamlFunctionCall<T>): AsyncGenerator<Partial<T>, T, unknown> {
    if (!this.initialized) {
      await this.initialize();
    }

    const model = call.model || this.config.defaultModel;
    console.log(`Executing streaming BAML function ${call.functionName} with model ${model}`);

    try {
      // Execute streaming function through BAML
      const stream = await this.executeFunctionStreamWithModel<T>(
        call.functionName,
        call.input,
        model,
        call.temperature
      );

      let finalResult: T | null = null;
      
      for await (const partial of stream) {
        yield partial;
        finalResult = partial as T;
      }

      if (finalResult && this.validateResult(finalResult, call.expectedOutput)) {
        return finalResult;
      } else {
        throw new Error('Stream result validation failed');
      }
    } catch (error) {
      console.error(`Stream failed with model ${model}:`, error);
      throw error;
    }
  }

  /**
   * Execute function with specific model
   */
  private async executeFunctionWithModel<T>(
    functionName: string,
    input: any,
    model: string,
    temperature?: number
  ): Promise<T> {
    // This would call the actual BAML runtime function
    // In practice, this would use the generated BAML client code
    const functionRef = (this.client as any)[functionName];
    if (!functionRef) {
      throw new Error(`BAML function ${functionName} not found`);
    }

    const options = {
      client: model,
      temperature: temperature ?? this.config.temperature,
    };

    return await functionRef(input, options) as T;
  }

  /**
   * Execute streaming function with specific model
   */
  private async executeFunctionStreamWithModel<T>(
    functionName: string,
    input: any,
    model: string,
    temperature?: number
  ): Promise<AsyncGenerator<Partial<T>, T, unknown>> {
    // This would call the actual BAML runtime streaming function
    const functionRef = (this.client as any)[functionName + 'Stream'];
    if (!functionRef) {
      throw new Error(`BAML streaming function ${functionName}Stream not found`);
    }

    const options = {
      client: model,
      temperature: temperature ?? this.config.temperature,
    };

    return functionRef(input, options) as AsyncGenerator<Partial<T>, T, unknown>;
  }

  /**
   * Validate result matches expected schema
   */
  private validateResult<T>(result: any, expectedType: new () => T): boolean {
    // Basic validation - in practice would use more sophisticated schema validation
    if (!result) {
      return false;
    }

    // Check if result has expected properties
    const instance = new expectedType();
    const expectedKeys = Object.keys(instance);
    const resultKeys = Object.keys(result);

    // All expected keys should be present in result
    return expectedKeys.every(key => resultKeys.includes(key));
  }

  /**
   * Get available models
   */
  getAvailableModels(): string[] {
    return [this.config.defaultModel, ...(this.config.fallbackModels || [])];
  }

  /**
   * Update model preferences
   */
  updateModelPreferences(defaultModel: string, fallbackModels?: string[]): void {
    this.config.defaultModel = defaultModel;
    if (fallbackModels) {
      this.config.fallbackModels = fallbackModels;
    }
  }

  /**
   * Get current configuration
   */
  getConfig(): Readonly<BamlConfig> {
    return { ...this.config };
  }
}

// Agent-specific BAML function wrappers
export class AgentBamlFunctions {
  constructor(private bamlClient: BamlClientWrapper) {}

  /**
   * Validate agent status update
   */
  async validateAgentStatus(status: any): Promise<boolean> {
    return this.bamlClient.executeFunction({
      functionName: 'validateAgentStatus',
      input: status,
      expectedOutput: Boolean as any,
      model: 'claude-sonnet' // Use faster model for validation
    });
  }

  /**
   * Generate agent status summary
   */
  async generateAgentStatusSummary(agents: any[]): Promise<string> {
    return this.bamlClient.executeFunction({
      functionName: 'generateAgentStatusSummary',
      input: { agents },
      expectedOutput: String as any,
      model: 'claude-sonnet'
    });
  }

  /**
   * Create GitHub issue from requirements (PM Agent)
   */
  async createGitHubIssueFromRequirements(
    requirements: string,
    projectContext: any
  ): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'createGitHubIssueFromRequirements',
      input: { requirements, projectContext },
      expectedOutput: Object as any, // GitHubIssueRequest
      model: 'claude-opus' // Use more capable model for complex generation
    });
  }

  /**
   * Generate technical specification (PM Agent)
   */
  async generateTechnicalSpecification(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'generateTechnicalSpecification',
      input: request,
      expectedOutput: Object as any, // TechnicalSpecification
      model: 'claude-opus'
    });
  }

  /**
   * Generate test specification from requirements (Coder Agent)
   */
  async generateTestSpecification(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'generateTestSpecification',
      input: request,
      expectedOutput: Object as any, // TestSpecification
      model: 'claude-opus'
    });
  }

  /**
   * Implement code from failing tests (Coder Agent)
   */
  async implementCodeFromTests(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'implementCodeFromTests',
      input: request,
      expectedOutput: Object as any, // CodeImplementation
      model: 'claude-opus'
    });
  }

  /**
   * Execute tests with configuration (Tester Agent)
   */
  async executeTests(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'executeTests',
      input: request,
      expectedOutput: Object as any, // TestExecutionResult
      model: 'claude-opus'
    });
  }

  /**
   * Analyze test results for issues (Tester Agent)
   */
  async analyzeTestResults(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'analyzeTestResults',
      input: request,
      expectedOutput: Object as any, // TestAnalysisResult
      model: 'claude-opus'
    });
  }

  /**
   * Perform comprehensive code review (Code Reviewer Agent)
   */
  async performCodeReview(request: any): Promise<any> {
    return this.bamlClient.executeFunction({
      functionName: 'performCodeReview',
      input: request,
      expectedOutput: Object as any, // CodeReviewResult
      model: 'claude-opus'
    });
  }

  /**
   * Perform security analysis (Code Reviewer Agent)
   */
  async performSecurityAnalysis(files: any[], config: any): Promise<any[]> {
    return this.bamlClient.executeFunction({
      functionName: 'performSecurityAnalysis',
      input: { files, config },
      expectedOutput: Array as any, // SecurityFinding[]
      model: 'claude-opus'
    });
  }
}